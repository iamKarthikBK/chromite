//
// Generated by Bluespec Compiler, version 2021.07-3-g8227dc97 (build 8227dc97)
//
// On Sat Oct  2 15:35:16 +0530 2021
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_inputs                  O     1 const
// mv_ready                       O     1
// RDY_mv_ready                   O     1 const
// mv_output_valid                O     1 reg
// RDY_mv_output_valid            O     1 const
// mv_output                      O    64 reg
// RDY_mv_output                  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_inputs_in1                  I    64
// ma_inputs_in2                  I    64
// ma_inputs_funct3               I     3
// ma_inputs_wordop               I     1
// EN_ma_inputs                   I     1
// EN_mv_output                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkrestoring_div(CLK,
		       RST_N,

		       ma_inputs_in1,
		       ma_inputs_in2,
		       ma_inputs_funct3,
		       ma_inputs_wordop,
		       EN_ma_inputs,
		       RDY_ma_inputs,

		       mv_ready,
		       RDY_mv_ready,

		       mv_output_valid,
		       RDY_mv_output_valid,

		       EN_mv_output,
		       mv_output,
		       RDY_mv_output);
  parameter [63 : 0] hartid = 64'b0;
  input  CLK;
  input  RST_N;

  // action method ma_inputs
  input  [63 : 0] ma_inputs_in1;
  input  [63 : 0] ma_inputs_in2;
  input  [2 : 0] ma_inputs_funct3;
  input  ma_inputs_wordop;
  input  EN_ma_inputs;
  output RDY_ma_inputs;

  // value method mv_ready
  output mv_ready;
  output RDY_mv_ready;

  // value method mv_output_valid
  output mv_output_valid;
  output RDY_mv_output_valid;

  // actionvalue method mv_output
  input  EN_mv_output;
  output [63 : 0] mv_output;
  output RDY_mv_output;

  // signals for module outputs
  wire [63 : 0] mv_output;
  wire RDY_ma_inputs,
       RDY_mv_output,
       RDY_mv_output_valid,
       RDY_mv_ready,
       mv_output_valid,
       mv_ready;

  // register partial
  reg [128 : 0] partial;
  wire [128 : 0] partial_D_IN;
  wire partial_EN;

  // register quotient_remainder
  reg quotient_remainder;
  wire quotient_remainder_D_IN, quotient_remainder_EN;

  // register rg_complement
  reg rg_complement;
  wire rg_complement_D_IN, rg_complement_EN;

  // register rg_count
  reg [5 : 0] rg_count;
  wire [5 : 0] rg_count_D_IN;
  wire rg_count_EN;

  // register rg_in1
  reg [63 : 0] rg_in1;
  wire [63 : 0] rg_in1_D_IN;
  wire rg_in1_EN;

  // register rg_op2
  reg [63 : 0] rg_op2;
  wire [63 : 0] rg_op2_D_IN;
  wire rg_op2_EN;

  // register rg_result
  reg [63 : 0] rg_result;
  wire [63 : 0] rg_result_D_IN;
  wire rg_result_EN;

  // register rg_sign_op1
  reg rg_sign_op1;
  wire rg_sign_op1_D_IN, rg_sign_op1_EN;

  // register rg_upperbits
  reg rg_upperbits;
  wire rg_upperbits_D_IN, rg_upperbits_EN;

  // register rg_valid
  reg rg_valid;
  wire rg_valid_D_IN, rg_valid_EN;

  // register rg_wordop
  reg rg_wordop;
  wire rg_wordop_D_IN, rg_wordop_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_single_step_div,
       CAN_FIRE_ma_inputs,
       CAN_FIRE_mv_output,
       WILL_FIRE_RL_single_step_div,
       WILL_FIRE_ma_inputs,
       WILL_FIRE_mv_output;

  // inputs to muxes for submodule ports
  wire [128 : 0] MUX_partial_write_1__VAL_1, MUX_partial_write_1__VAL_2;
  wire [5 : 0] MUX_rg_count_write_1__VAL_1;
  wire MUX_rg_valid_write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_testplusargs___d86;
  reg TASK_testplusargs___d87;
  reg TASK_testplusargs___d88;
  reg [63 : 0] v__h1466;
  reg TASK_testplusargs___d30;
  reg TASK_testplusargs___d31;
  reg TASK_testplusargs___d32;
  reg [63 : 0] v__h715;
  reg TASK_testplusargs___d69;
  reg TASK_testplusargs___d70;
  reg TASK_testplusargs___d71;
  reg [63 : 0] v__h897;
  reg TASK_testplusargs___d78;
  reg TASK_testplusargs___d79;
  reg TASK_testplusargs___d80;
  reg [63 : 0] v__h1320;
  reg rg_count_EQ_33_8_AND_TASK_testplusargs_8_OR_TA_ETC___d83;
  reg rg_op2_EQ_0_7_AND_TASK_testplusargs_9_OR_TASK__ETC___d74;
  // synopsys translate_on

  // remaining internal signals
  wire [64 : 0] IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d16,
		SEXT_INV_rg_op2_2_PLUS_1_3___d14,
		remainder__h499,
		sub__h501,
		sub__h512,
		upper__h426;
  wire [63 : 0] IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d100,
		IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d112,
		IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC___d44,
		IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC___d64,
		_theResult___fst__h1686,
		_theResult___snd__h1687,
		lower__h427,
		op1__h1545,
		product__h1068,
		product__h1142,
		reslt___1__h1252,
		reslt__h1140,
		t1__h1590,
		t2__h1591,
		x__h550;
  wire [31 : 0] IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC__q4,
		IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC__q3,
		ma_inputs_in1_BITS_31_TO_0__q1,
		ma_inputs_in2_BITS_31_TO_0__q2;
  wire [5 : 0] x__h826;
  wire IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d20,
       IF_quotient_remainder_6_THEN_partial_BITS_127__ETC___d56,
       partial_BITS_126_TO_63_ULT_rg_op2___d10,
       x__h1768,
       x__h1804;

  // action method ma_inputs
  assign RDY_ma_inputs = 1'd1 ;
  assign CAN_FIRE_ma_inputs = 1'd1 ;
  assign WILL_FIRE_ma_inputs = EN_ma_inputs ;

  // value method mv_ready
  assign mv_ready = rg_count == 6'd0 && !rg_valid ;
  assign RDY_mv_ready = 1'd1 ;

  // value method mv_output_valid
  assign mv_output_valid = rg_valid ;
  assign RDY_mv_output_valid = 1'd1 ;

  // actionvalue method mv_output
  assign mv_output = rg_result ;
  assign RDY_mv_output = 1'd1 ;
  assign CAN_FIRE_mv_output = 1'd1 ;
  assign WILL_FIRE_mv_output = EN_mv_output ;

  // rule RL_single_step_div
  assign CAN_FIRE_RL_single_step_div = rg_count != 6'd0 && !rg_valid ;
  assign WILL_FIRE_RL_single_step_div = CAN_FIRE_RL_single_step_div ;

  // inputs to muxes for submodule ports
  assign MUX_rg_valid_write_1__SEL_1 =
	     WILL_FIRE_RL_single_step_div &&
	     (rg_op2 == 64'd0 || rg_count == 6'd33) ;
  assign MUX_partial_write_1__VAL_1 = { upper__h426, lower__h427 } ;
  assign MUX_partial_write_1__VAL_2 = { 65'd0, op1__h1545 } ;
  assign MUX_rg_count_write_1__VAL_1 =
	     (rg_op2 == 64'd0 || rg_count == 6'd33) ? 6'd0 : x__h826 ;

  // register partial
  assign partial_D_IN =
	     WILL_FIRE_RL_single_step_div ?
	       MUX_partial_write_1__VAL_1 :
	       MUX_partial_write_1__VAL_2 ;
  assign partial_EN = WILL_FIRE_RL_single_step_div || EN_ma_inputs ;

  // register quotient_remainder
  assign quotient_remainder_D_IN = ma_inputs_funct3[1] ;
  assign quotient_remainder_EN = EN_ma_inputs ;

  // register rg_complement
  assign rg_complement_D_IN =
	     (ma_inputs_funct3 == 3'd4) ?
	       IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d100[63] ^
	       IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d112[63] :
	       ma_inputs_funct3 == 3'd6 ;
  assign rg_complement_EN = EN_ma_inputs ;

  // register rg_count
  assign rg_count_D_IN =
	     WILL_FIRE_RL_single_step_div ?
	       MUX_rg_count_write_1__VAL_1 :
	       x__h826 ;
  assign rg_count_EN = EN_ma_inputs || WILL_FIRE_RL_single_step_div ;

  // register rg_in1
  assign rg_in1_D_IN = ma_inputs_in1 ;
  assign rg_in1_EN = EN_ma_inputs ;

  // register rg_op2
  assign rg_op2_D_IN =
	     (t2__h1591 ^
	      IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d112) +
	     { 63'd0, x__h1804 } ;
  assign rg_op2_EN = EN_ma_inputs ;

  // register rg_result
  assign rg_result_D_IN =
	     (rg_op2 == 64'd0) ? product__h1068 : product__h1142 ;
  assign rg_result_EN = MUX_rg_valid_write_1__SEL_1 ;

  // register rg_sign_op1
  assign rg_sign_op1_D_IN =
	     IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d100[63] ;
  assign rg_sign_op1_EN = EN_ma_inputs ;

  // register rg_upperbits
  assign rg_upperbits_D_IN = ma_inputs_funct3[1] ;
  assign rg_upperbits_EN = EN_ma_inputs ;

  // register rg_valid
  assign rg_valid_D_IN = MUX_rg_valid_write_1__SEL_1 ;
  assign rg_valid_EN =
	     WILL_FIRE_RL_single_step_div &&
	     (rg_op2 == 64'd0 || rg_count == 6'd33) ||
	     EN_mv_output ;

  // register rg_wordop
  assign rg_wordop_D_IN = ma_inputs_wordop ;
  assign rg_wordop_EN = EN_ma_inputs ;

  // remaining internal signals
  assign IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d100 =
	     ma_inputs_wordop ? _theResult___fst__h1686 : ma_inputs_in1 ;
  assign IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d112 =
	     ma_inputs_wordop ? _theResult___snd__h1687 : ma_inputs_in2 ;
  assign IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d16 =
	     partial_BITS_126_TO_63_ULT_rg_op2___d10 ?
	       partial[127:63] :
	       sub__h512 ;
  assign IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d20 =
	     { IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d16[62:0],
	       partial[62] } <
	     rg_op2 ;
  assign IF_quotient_remainder_6_THEN_partial_BITS_127__ETC___d56 =
	     reslt__h1140[63] == rg_sign_op1 ;
  assign IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC___d44 =
	     quotient_remainder ? rg_in1 : 64'hFFFFFFFFFFFFFFFF ;
  assign IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC__q4 =
	     IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC___d44[31:0] ;
  assign IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC___d64 =
	     (rg_upperbits && rg_complement &&
	      !IF_quotient_remainder_6_THEN_partial_BITS_127__ETC___d56 ||
	      rg_complement && !rg_upperbits) ?
	       reslt___1__h1252 :
	       reslt__h1140 ;
  assign IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC__q3 =
	     IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC___d64[31:0] ;
  assign SEXT_INV_rg_op2_2_PLUS_1_3___d14 = { x__h550[63], x__h550 } ;
  assign _theResult___fst__h1686 =
	     ma_inputs_funct3[0] ?
	       { 32'd0, ma_inputs_in1[31:0] } :
	       { {32{ma_inputs_in1_BITS_31_TO_0__q1[31]}},
		 ma_inputs_in1_BITS_31_TO_0__q1 } ;
  assign _theResult___snd__h1687 =
	     ma_inputs_funct3[0] ?
	       { 32'd0, ma_inputs_in2[31:0] } :
	       { {32{ma_inputs_in2_BITS_31_TO_0__q2[31]}},
		 ma_inputs_in2_BITS_31_TO_0__q2 } ;
  assign lower__h427 =
	     { partial[61:0],
	       !partial_BITS_126_TO_63_ULT_rg_op2___d10,
	       !IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d20 } ;
  assign ma_inputs_in1_BITS_31_TO_0__q1 = ma_inputs_in1[31:0] ;
  assign ma_inputs_in2_BITS_31_TO_0__q2 = ma_inputs_in2[31:0] ;
  assign op1__h1545 =
	     (t1__h1590 ^
	      IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d100) +
	     { 63'd0, x__h1768 } ;
  assign partial_BITS_126_TO_63_ULT_rg_op2___d10 = partial[126:63] < rg_op2 ;
  assign product__h1068 =
	     rg_wordop ?
	       { {32{IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC__q4[31]}},
		 IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC__q4 } :
	       IF_quotient_remainder_6_THEN_rg_in1_3_ELSE_184_ETC___d44 ;
  assign product__h1142 =
	     rg_wordop ?
	       { {32{IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC__q3[31]}},
		 IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC__q3 } :
	       IF_rg_upperbits_8_AND_rg_complement_9_0_AND_NO_ETC___d64 ;
  assign remainder__h499 =
	     { IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d16[63:0],
	       partial[62] } ;
  assign reslt___1__h1252 = ~reslt__h1140 + 64'd1 ;
  assign reslt__h1140 = quotient_remainder ? partial[127:64] : partial[63:0] ;
  assign sub__h501 = remainder__h499 + SEXT_INV_rg_op2_2_PLUS_1_3___d14 ;
  assign sub__h512 = partial[127:63] + SEXT_INV_rg_op2_2_PLUS_1_3___d14 ;
  assign t1__h1590 = {64{x__h1768}} ;
  assign t2__h1591 = {64{x__h1804}} ;
  assign upper__h426 =
	     IF_partial_BITS_126_TO_63_ULT_rg_op2_0_THEN_pa_ETC___d20 ?
	       remainder__h499 :
	       sub__h501 ;
  assign x__h1768 =
	     ma_inputs_funct3[2] && !ma_inputs_funct3[0] &&
	     IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d100[63] ;
  assign x__h1804 =
	     ma_inputs_funct3[2] && !ma_inputs_funct3[0] &&
	     IF_ma_inputs_wordop_THEN_IF_ma_inputs_funct3_B_ETC___d112[63] ;
  assign x__h550 = ~rg_op2 + 64'd1 ;
  assign x__h826 = rg_count + 6'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        partial <= `BSV_ASSIGNMENT_DELAY 129'd0;
	quotient_remainder <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_complement <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_count <= `BSV_ASSIGNMENT_DELAY 6'd0;
	rg_in1 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_op2 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_result <= `BSV_ASSIGNMENT_DELAY 64'd0;
	rg_sign_op1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_upperbits <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_valid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_wordop <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (partial_EN) partial <= `BSV_ASSIGNMENT_DELAY partial_D_IN;
	if (quotient_remainder_EN)
	  quotient_remainder <= `BSV_ASSIGNMENT_DELAY quotient_remainder_D_IN;
	if (rg_complement_EN)
	  rg_complement <= `BSV_ASSIGNMENT_DELAY rg_complement_D_IN;
	if (rg_count_EN) rg_count <= `BSV_ASSIGNMENT_DELAY rg_count_D_IN;
	if (rg_in1_EN) rg_in1 <= `BSV_ASSIGNMENT_DELAY rg_in1_D_IN;
	if (rg_op2_EN) rg_op2 <= `BSV_ASSIGNMENT_DELAY rg_op2_D_IN;
	if (rg_result_EN) rg_result <= `BSV_ASSIGNMENT_DELAY rg_result_D_IN;
	if (rg_sign_op1_EN)
	  rg_sign_op1 <= `BSV_ASSIGNMENT_DELAY rg_sign_op1_D_IN;
	if (rg_upperbits_EN)
	  rg_upperbits <= `BSV_ASSIGNMENT_DELAY rg_upperbits_D_IN;
	if (rg_valid_EN) rg_valid <= `BSV_ASSIGNMENT_DELAY rg_valid_D_IN;
	if (rg_wordop_EN) rg_wordop <= `BSV_ASSIGNMENT_DELAY rg_wordop_D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    partial = 129'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    quotient_remainder = 1'h0;
    rg_complement = 1'h0;
    rg_count = 6'h2A;
    rg_in1 = 64'hAAAAAAAAAAAAAAAA;
    rg_op2 = 64'hAAAAAAAAAAAAAAAA;
    rg_result = 64'hAAAAAAAAAAAAAAAA;
    rg_sign_op1 = 1'h0;
    rg_upperbits = 1'h0;
    rg_valid = 1'h0;
    rg_wordop = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs)
	begin
	  TASK_testplusargs___d86 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs)
	begin
	  TASK_testplusargs___d87 = $test$plusargs("mdivider");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs)
	begin
	  TASK_testplusargs___d88 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs)
	begin
	  v__h1466 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs &&
	  (TASK_testplusargs___d86 ||
	   TASK_testplusargs___d87 && TASK_testplusargs___d88))
	$write("[%10d", v__h1466, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs &&
	  (TASK_testplusargs___d86 ||
	   TASK_testplusargs___d87 && TASK_testplusargs___d88))
	$write("[%2d]DIV: Got inputs rg_count: %d", hartid, rg_count);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_inputs &&
	  (TASK_testplusargs___d86 ||
	   TASK_testplusargs___d87 && TASK_testplusargs___d88))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div)
	begin
	  TASK_testplusargs___d30 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div)
	begin
	  TASK_testplusargs___d31 = $test$plusargs("mdivider");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div)
	begin
	  TASK_testplusargs___d32 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div)
	begin
	  v__h715 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div &&
	  (TASK_testplusargs___d30 ||
	   TASK_testplusargs___d31 && TASK_testplusargs___d32))
	$write("[%10d", v__h715, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div &&
	  (TASK_testplusargs___d30 ||
	   TASK_testplusargs___d31 && TASK_testplusargs___d32))
	$write("[%2d]DIV: RgCount:%d partial:%h QR:%b",
	       hartid,
	       rg_count,
	       partial,
	       quotient_remainder);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div &&
	  (TASK_testplusargs___d30 ||
	   TASK_testplusargs___d31 && TASK_testplusargs___d32))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 == 64'd0)
	begin
	  TASK_testplusargs___d69 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 == 64'd0)
	begin
	  TASK_testplusargs___d70 = $test$plusargs("mdivider");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 == 64'd0)
	begin
	  TASK_testplusargs___d71 = $test$plusargs("l0");
	  #0;
	end
    rg_op2_EQ_0_7_AND_TASK_testplusargs_9_OR_TASK__ETC___d74 =
	rg_op2 == 64'd0 &&
	(TASK_testplusargs___d69 ||
	 TASK_testplusargs___d70 && TASK_testplusargs___d71);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 == 64'd0)
	begin
	  v__h897 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div &&
	  rg_op2_EQ_0_7_AND_TASK_testplusargs_9_OR_TASK__ETC___d74)
	$write("[%10d", v__h897, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div &&
	  rg_op2_EQ_0_7_AND_TASK_testplusargs_9_OR_TASK__ETC___d74)
	$write("[%2d] DIV: Divide by zero detected. RgCount:%d",
	       hartid,
	       rg_count);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div &&
	  rg_op2_EQ_0_7_AND_TASK_testplusargs_9_OR_TASK__ETC___d74)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count == 6'd33)
	begin
	  TASK_testplusargs___d78 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count == 6'd33)
	begin
	  TASK_testplusargs___d79 = $test$plusargs("mdivider");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count == 6'd33)
	begin
	  TASK_testplusargs___d80 = $test$plusargs("l0");
	  #0;
	end
    rg_count_EQ_33_8_AND_TASK_testplusargs_8_OR_TA_ETC___d83 =
	rg_count == 6'd33 &&
	(TASK_testplusargs___d78 ||
	 TASK_testplusargs___d79 && TASK_testplusargs___d80);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count == 6'd33)
	begin
	  v__h1320 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count_EQ_33_8_AND_TASK_testplusargs_8_OR_TA_ETC___d83)
	$write("[%10d", v__h1320, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count_EQ_33_8_AND_TASK_testplusargs_8_OR_TA_ETC___d83)
	$write("[%2d] DIV: Sending output:%h", hartid, product__h1142);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_single_step_div && rg_op2 != 64'd0 &&
	  rg_count_EQ_33_8_AND_TASK_testplusargs_8_OR_TA_ETC___d83)
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkrestoring_div

