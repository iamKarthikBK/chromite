//
// Generated by Bluespec Compiler, version 2021.07-3-g8227dc97 (build 8227dc97)
//
// On Sat Oct  2 15:35:35 +0530 2021
//
//
// Ports:
// Name                         I/O  size props
// mv_io_full                     O     1
// RDY_mv_io_full                 O     1 const
// mv_io_empty                    O     1
// RDY_mv_io_empty                O     1 const
// mv_io_head_valid               O     1
// RDY_mv_io_head_valid           O     1 const
// RDY_ma_increment_head          O     1 const
// RDY_ma_commit_io               O     1 const
// mv_io_head                     O   172
// RDY_mv_io_head                 O     1 const
// RDY_ma_allocate_io             O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_allocate_io_entry           I   172
// EN_ma_increment_head           I     1
// EN_ma_commit_io                I     1
// EN_ma_allocate_io              I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkiobuffer(CLK,
		  RST_N,

		  mv_io_full,
		  RDY_mv_io_full,

		  mv_io_empty,
		  RDY_mv_io_empty,

		  mv_io_head_valid,
		  RDY_mv_io_head_valid,

		  EN_ma_increment_head,
		  RDY_ma_increment_head,

		  EN_ma_commit_io,
		  RDY_ma_commit_io,

		  mv_io_head,
		  RDY_mv_io_head,

		  ma_allocate_io_entry,
		  EN_ma_allocate_io,
		  RDY_ma_allocate_io);
  parameter [31 : 0] id = 32'b0;
  input  CLK;
  input  RST_N;

  // value method mv_io_full
  output mv_io_full;
  output RDY_mv_io_full;

  // value method mv_io_empty
  output mv_io_empty;
  output RDY_mv_io_empty;

  // value method mv_io_head_valid
  output mv_io_head_valid;
  output RDY_mv_io_head_valid;

  // action method ma_increment_head
  input  EN_ma_increment_head;
  output RDY_ma_increment_head;

  // action method ma_commit_io
  input  EN_ma_commit_io;
  output RDY_ma_commit_io;

  // value method mv_io_head
  output [171 : 0] mv_io_head;
  output RDY_mv_io_head;

  // action method ma_allocate_io
  input  [171 : 0] ma_allocate_io_entry;
  input  EN_ma_allocate_io;
  output RDY_ma_allocate_io;

  // signals for module outputs
  wire [171 : 0] mv_io_head;
  wire RDY_ma_allocate_io,
       RDY_ma_commit_io,
       RDY_ma_increment_head,
       RDY_mv_io_empty,
       RDY_mv_io_full,
       RDY_mv_io_head,
       RDY_mv_io_head_valid,
       mv_io_empty,
       mv_io_full,
       mv_io_head_valid;

  // register rg_head
  reg rg_head;
  wire rg_head_D_IN, rg_head_EN;

  // register rg_tail
  reg rg_tail;
  wire rg_tail_D_IN, rg_tail_EN;

  // register v_iobuff_commit_0
  reg v_iobuff_commit_0;
  wire v_iobuff_commit_0_D_IN, v_iobuff_commit_0_EN;

  // register v_iobuff_commit_1
  reg v_iobuff_commit_1;
  wire v_iobuff_commit_1_D_IN, v_iobuff_commit_1_EN;

  // register v_iobuff_valid_0
  reg v_iobuff_valid_0;
  wire v_iobuff_valid_0_D_IN, v_iobuff_valid_0_EN;

  // register v_iobuff_valid_1
  reg v_iobuff_valid_1;
  wire v_iobuff_valid_1_D_IN, v_iobuff_valid_1_EN;

  // register v_iobuffer_0
  reg [171 : 0] v_iobuffer_0;
  wire [171 : 0] v_iobuffer_0_D_IN;
  wire v_iobuffer_0_EN;

  // register v_iobuffer_1
  reg [171 : 0] v_iobuffer_1;
  wire [171 : 0] v_iobuffer_1_D_IN;
  wire v_iobuffer_1_EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_print_stats,
       CAN_FIRE_ma_allocate_io,
       CAN_FIRE_ma_commit_io,
       CAN_FIRE_ma_increment_head,
       WILL_FIRE_RL_rl_print_stats,
       WILL_FIRE_ma_allocate_io,
       WILL_FIRE_ma_commit_io,
       WILL_FIRE_ma_increment_head;

  // inputs to muxes for submodule ports
  wire MUX_v_iobuff_commit_0_write_1__SEL_1,
       MUX_v_iobuff_commit_0_write_1__VAL_1,
       MUX_v_iobuff_commit_1_write_1__SEL_1,
       MUX_v_iobuff_commit_1_write_1__VAL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_testplusargs___d1;
  reg TASK_testplusargs___d2;
  reg TASK_testplusargs___d3;
  reg [63 : 0] v__h719;
  reg TASK_testplusargs___d77;
  reg TASK_testplusargs___d78;
  reg TASK_testplusargs___d79;
  reg [63 : 0] v__h2097;
  reg TASK_testplusargs_7_OR_TASK_testplusargs_8_AND_ETC___d83;
  reg TASK_testplusargs_7_OR_TASK_testplusargs_8_AND_ETC___d91;
  // synopsys translate_on

  // remaining internal signals
  reg [63 : 0] CASE_rg_head_0_v_iobuffer_0_BITS_139_TO_76_1_v_ETC__q10,
	       CASE_rg_head_0_v_iobuffer_0_BITS_64_TO_1_1_v_i_ETC__q5;
  reg [31 : 0] CASE_rg_head_0_v_iobuffer_0_BITS_171_TO_140_1__ETC__q9;
  reg [4 : 0] CASE_rg_head_0_v_iobuffer_0_BITS_69_TO_65_1_v__ETC__q4;
  reg [2 : 0] CASE_rg_head_0_v_iobuffer_0_BITS_75_TO_73_1_v__ETC__q7;
  reg [1 : 0] CASE_rg_head_0_v_iobuffer_0_BITS_71_TO_70_1_v__ETC__q3;
  reg CASE_rg_head_0_v_iobuff_commit_0_1_v_iobuff_co_ETC__q2,
      CASE_rg_head_0_v_iobuff_valid_0_1_v_iobuff_val_ETC__q1,
      CASE_rg_head_0_v_iobuffer_0_BIT_0_1_v_iobuffer_ETC__q6,
      CASE_rg_head_0_v_iobuffer_0_BIT_72_1_v_iobuffe_ETC__q8,
      CASE_rg_tail_0_NOT_v_iobuff_valid_0_1_NOT_v_io_ETC__q11;
  wire [75 : 0] SEL_ARR_v_iobuffer_0_6_BITS_75_TO_73_6_v_iobuf_ETC___d62;
  wire [71 : 0] SEL_ARR_v_iobuffer_0_6_BITS_71_TO_70_4_v_iobuf_ETC___d61;
  wire NOT_SEL_ARR_NOT_v_iobuff_valid_0_0_NOT_v_iobuf_ETC___d65,
       x__h1324,
       x__h1878;

  // value method mv_io_full
  assign mv_io_full = v_iobuff_valid_0 && v_iobuff_valid_1 ;
  assign RDY_mv_io_full = 1'd1 ;

  // value method mv_io_empty
  assign mv_io_empty = !v_iobuff_valid_0 && !v_iobuff_valid_1 ;
  assign RDY_mv_io_empty = 1'd1 ;

  // value method mv_io_head_valid
  assign mv_io_head_valid =
	     CASE_rg_head_0_v_iobuff_valid_0_1_v_iobuff_val_ETC__q1 &&
	     CASE_rg_head_0_v_iobuff_commit_0_1_v_iobuff_co_ETC__q2 ;
  assign RDY_mv_io_head_valid = 1'd1 ;

  // action method ma_increment_head
  assign RDY_ma_increment_head = 1'd1 ;
  assign CAN_FIRE_ma_increment_head = 1'd1 ;
  assign WILL_FIRE_ma_increment_head = EN_ma_increment_head ;

  // action method ma_commit_io
  assign RDY_ma_commit_io = 1'd1 ;
  assign CAN_FIRE_ma_commit_io = 1'd1 ;
  assign WILL_FIRE_ma_commit_io = EN_ma_commit_io ;

  // value method mv_io_head
  assign mv_io_head =
	     { CASE_rg_head_0_v_iobuffer_0_BITS_171_TO_140_1__ETC__q9,
	       CASE_rg_head_0_v_iobuffer_0_BITS_139_TO_76_1_v_ETC__q10,
	       SEL_ARR_v_iobuffer_0_6_BITS_75_TO_73_6_v_iobuf_ETC___d62 } ;
  assign RDY_mv_io_head = 1'd1 ;

  // action method ma_allocate_io
  assign RDY_ma_allocate_io = 1'd1 ;
  assign CAN_FIRE_ma_allocate_io = 1'd1 ;
  assign WILL_FIRE_ma_allocate_io = EN_ma_allocate_io ;

  // rule RL_rl_print_stats
  assign CAN_FIRE_RL_rl_print_stats = 1'd1 ;
  assign WILL_FIRE_RL_rl_print_stats = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_v_iobuff_commit_0_write_1__SEL_1 =
	     EN_ma_allocate_io && rg_tail == 1'd0 ;
  assign MUX_v_iobuff_commit_1_write_1__SEL_1 =
	     EN_ma_allocate_io && rg_tail == 1'd1 ;
  assign MUX_v_iobuff_commit_0_write_1__VAL_1 =
	     rg_tail == 1'd0 && ma_allocate_io_entry[0] ;
  assign MUX_v_iobuff_commit_1_write_1__VAL_1 =
	     rg_tail == 1'd1 && ma_allocate_io_entry[0] ;

  // register rg_head
  assign rg_head_D_IN = !rg_head && x__h1324 ;
  assign rg_head_EN = EN_ma_increment_head ;

  // register rg_tail
  assign rg_tail_D_IN = !rg_tail && x__h1878 ;
  assign rg_tail_EN = EN_ma_allocate_io ;

  // register v_iobuff_commit_0
  assign v_iobuff_commit_0_D_IN =
	     !MUX_v_iobuff_commit_0_write_1__SEL_1 ||
	     MUX_v_iobuff_commit_0_write_1__VAL_1 ;
  assign v_iobuff_commit_0_EN =
	     EN_ma_allocate_io && rg_tail == 1'd0 ||
	     EN_ma_commit_io && rg_head == 1'd0 ;

  // register v_iobuff_commit_1
  assign v_iobuff_commit_1_D_IN =
	     !MUX_v_iobuff_commit_1_write_1__SEL_1 ||
	     MUX_v_iobuff_commit_1_write_1__VAL_1 ;
  assign v_iobuff_commit_1_EN =
	     EN_ma_allocate_io && rg_tail == 1'd1 ||
	     EN_ma_commit_io && rg_head == 1'd1 ;

  // register v_iobuff_valid_0
  assign v_iobuff_valid_0_D_IN = MUX_v_iobuff_commit_0_write_1__SEL_1 ;
  assign v_iobuff_valid_0_EN =
	     EN_ma_allocate_io && rg_tail == 1'd0 ||
	     EN_ma_increment_head && rg_head == 1'd0 ;

  // register v_iobuff_valid_1
  assign v_iobuff_valid_1_D_IN = MUX_v_iobuff_commit_1_write_1__SEL_1 ;
  assign v_iobuff_valid_1_EN =
	     EN_ma_allocate_io && rg_tail == 1'd1 ||
	     EN_ma_increment_head && rg_head == 1'd1 ;

  // register v_iobuffer_0
  assign v_iobuffer_0_D_IN = ma_allocate_io_entry ;
  assign v_iobuffer_0_EN = MUX_v_iobuff_commit_0_write_1__SEL_1 ;

  // register v_iobuffer_1
  assign v_iobuffer_1_D_IN = ma_allocate_io_entry ;
  assign v_iobuffer_1_EN = MUX_v_iobuff_commit_1_write_1__SEL_1 ;

  // remaining internal signals
  assign NOT_SEL_ARR_NOT_v_iobuff_valid_0_0_NOT_v_iobuf_ETC___d65 =
	     !CASE_rg_tail_0_NOT_v_iobuff_valid_0_1_NOT_v_io_ETC__q11 ;
  assign SEL_ARR_v_iobuffer_0_6_BITS_71_TO_70_4_v_iobuf_ETC___d61 =
	     { CASE_rg_head_0_v_iobuffer_0_BITS_71_TO_70_1_v__ETC__q3,
	       CASE_rg_head_0_v_iobuffer_0_BITS_69_TO_65_1_v__ETC__q4,
	       CASE_rg_head_0_v_iobuffer_0_BITS_64_TO_1_1_v_i_ETC__q5,
	       CASE_rg_head_0_v_iobuffer_0_BIT_0_1_v_iobuffer_ETC__q6 } ;
  assign SEL_ARR_v_iobuffer_0_6_BITS_75_TO_73_6_v_iobuf_ETC___d62 =
	     { CASE_rg_head_0_v_iobuffer_0_BITS_75_TO_73_1_v__ETC__q7,
	       CASE_rg_head_0_v_iobuffer_0_BIT_72_1_v_iobuffe_ETC__q8,
	       SEL_ARR_v_iobuffer_0_6_BITS_71_TO_70_4_v_iobuf_ETC___d61 } ;
  assign x__h1324 = rg_head + 1'd1 ;
  assign x__h1878 = rg_tail + 1'd1 ;
  always@(rg_head or v_iobuff_valid_0 or v_iobuff_valid_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuff_valid_0_1_v_iobuff_val_ETC__q1 =
	      v_iobuff_valid_0;
      1'd1:
	  CASE_rg_head_0_v_iobuff_valid_0_1_v_iobuff_val_ETC__q1 =
	      v_iobuff_valid_1;
    endcase
  end
  always@(rg_head or v_iobuff_commit_0 or v_iobuff_commit_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuff_commit_0_1_v_iobuff_co_ETC__q2 =
	      v_iobuff_commit_0;
      1'd1:
	  CASE_rg_head_0_v_iobuff_commit_0_1_v_iobuff_co_ETC__q2 =
	      v_iobuff_commit_1;
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BITS_71_TO_70_1_v__ETC__q3 =
	      v_iobuffer_0[71:70];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BITS_71_TO_70_1_v__ETC__q3 =
	      v_iobuffer_1[71:70];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BITS_69_TO_65_1_v__ETC__q4 =
	      v_iobuffer_0[69:65];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BITS_69_TO_65_1_v__ETC__q4 =
	      v_iobuffer_1[69:65];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BITS_64_TO_1_1_v_i_ETC__q5 =
	      v_iobuffer_0[64:1];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BITS_64_TO_1_1_v_i_ETC__q5 =
	      v_iobuffer_1[64:1];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BIT_0_1_v_iobuffer_ETC__q6 =
	      v_iobuffer_0[0];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BIT_0_1_v_iobuffer_ETC__q6 =
	      v_iobuffer_1[0];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BITS_75_TO_73_1_v__ETC__q7 =
	      v_iobuffer_0[75:73];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BITS_75_TO_73_1_v__ETC__q7 =
	      v_iobuffer_1[75:73];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BIT_72_1_v_iobuffe_ETC__q8 =
	      v_iobuffer_0[72];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BIT_72_1_v_iobuffe_ETC__q8 =
	      v_iobuffer_1[72];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BITS_171_TO_140_1__ETC__q9 =
	      v_iobuffer_0[171:140];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BITS_171_TO_140_1__ETC__q9 =
	      v_iobuffer_1[171:140];
    endcase
  end
  always@(rg_head or v_iobuffer_0 or v_iobuffer_1)
  begin
    case (rg_head)
      1'd0:
	  CASE_rg_head_0_v_iobuffer_0_BITS_139_TO_76_1_v_ETC__q10 =
	      v_iobuffer_0[139:76];
      1'd1:
	  CASE_rg_head_0_v_iobuffer_0_BITS_139_TO_76_1_v_ETC__q10 =
	      v_iobuffer_1[139:76];
    endcase
  end
  always@(rg_tail or v_iobuff_valid_0 or v_iobuff_valid_1)
  begin
    case (rg_tail)
      1'd0:
	  CASE_rg_tail_0_NOT_v_iobuff_valid_0_1_NOT_v_io_ETC__q11 =
	      !v_iobuff_valid_0;
      1'd1:
	  CASE_rg_tail_0_NOT_v_iobuff_valid_0_1_NOT_v_io_ETC__q11 =
	      !v_iobuff_valid_1;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      rg_head <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_tail <= `BSV_ASSIGNMENT_DELAY 1'd0;
      v_iobuff_commit_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      v_iobuff_commit_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      v_iobuff_valid_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      v_iobuff_valid_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      v_iobuffer_0 <= `BSV_ASSIGNMENT_DELAY 172'd0;
      v_iobuffer_1 <= `BSV_ASSIGNMENT_DELAY 172'd0;
    end
  else
    begin
      if (rg_head_EN) rg_head <= `BSV_ASSIGNMENT_DELAY rg_head_D_IN;
      if (rg_tail_EN) rg_tail <= `BSV_ASSIGNMENT_DELAY rg_tail_D_IN;
      if (v_iobuff_commit_0_EN)
	v_iobuff_commit_0 <= `BSV_ASSIGNMENT_DELAY v_iobuff_commit_0_D_IN;
      if (v_iobuff_commit_1_EN)
	v_iobuff_commit_1 <= `BSV_ASSIGNMENT_DELAY v_iobuff_commit_1_D_IN;
      if (v_iobuff_valid_0_EN)
	v_iobuff_valid_0 <= `BSV_ASSIGNMENT_DELAY v_iobuff_valid_0_D_IN;
      if (v_iobuff_valid_1_EN)
	v_iobuff_valid_1 <= `BSV_ASSIGNMENT_DELAY v_iobuff_valid_1_D_IN;
      if (v_iobuffer_0_EN)
	v_iobuffer_0 <= `BSV_ASSIGNMENT_DELAY v_iobuffer_0_D_IN;
      if (v_iobuffer_1_EN)
	v_iobuffer_1 <= `BSV_ASSIGNMENT_DELAY v_iobuffer_1_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_head = 1'h0;
    rg_tail = 1'h0;
    v_iobuff_commit_0 = 1'h0;
    v_iobuff_commit_1 = 1'h0;
    v_iobuff_valid_0 = 1'h0;
    v_iobuff_valid_1 = 1'h0;
    v_iobuffer_0 = 172'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    v_iobuffer_1 = 172'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      begin
        TASK_testplusargs___d1 = $test$plusargs("fullverbose");
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      begin
        TASK_testplusargs___d2 = $test$plusargs("mdcache");
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      begin
        TASK_testplusargs___d3 = $test$plusargs("l3");
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      begin
        v__h719 = $time;
	#0;
      end
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d1 ||
	  TASK_testplusargs___d2 && TASK_testplusargs___d3)
	$write("[%10d", v__h719, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d1 ||
	  TASK_testplusargs___d2 && TASK_testplusargs___d3)
	$write("[%2d]DCACHE: io_full:%b io_empty:%b iohead:%d iotail:%d",
	       id,
	       v_iobuff_valid_0 && v_iobuff_valid_1,
	       !v_iobuff_valid_0 && !v_iobuff_valid_1,
	       rg_head,
	       rg_tail);
    if (RST_N != `BSV_RESET_VALUE)
      if (TASK_testplusargs___d1 ||
	  TASK_testplusargs___d2 && TASK_testplusargs___d3)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io &&
	  NOT_SEL_ARR_NOT_v_iobuff_valid_0_0_NOT_v_iobuf_ETC___d65)
	$display("Dynamic assertion failed: \"cache_subsystem/src/dcache/dcache_lib.bsv\", line 1451, column 46\nValid IO Entry Allocated");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io &&
	  NOT_SEL_ARR_NOT_v_iobuff_valid_0_0_NOT_v_iobuf_ETC___d65)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io)
	begin
	  TASK_testplusargs___d77 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io)
	begin
	  TASK_testplusargs___d78 = $test$plusargs("mdcache");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io)
	begin
	  TASK_testplusargs___d79 = $test$plusargs("l0");
	  #0;
	end
    TASK_testplusargs_7_OR_TASK_testplusargs_8_AND_ETC___d83 =
	(TASK_testplusargs___d77 ||
	 TASK_testplusargs___d78 && TASK_testplusargs___d79) &&
	ma_allocate_io_entry[0];
    TASK_testplusargs_7_OR_TASK_testplusargs_8_AND_ETC___d91 =
	(TASK_testplusargs___d77 ||
	 TASK_testplusargs___d78 && TASK_testplusargs___d79) &&
	!ma_allocate_io_entry[0];
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io)
	begin
	  v__h2097 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io &&
	  (TASK_testplusargs___d77 ||
	   TASK_testplusargs___d78 && TASK_testplusargs___d79))
	$write("[%10d", v__h2097, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io &&
	  TASK_testplusargs_7_OR_TASK_testplusargs_8_AND_ETC___d83)
	$write("DCACHE: Allocating IO Buff tail:%d",
	       rg_tail,
	       "IoEntry { ",
	       "address: ",
	       "'h%h",
	       ma_allocate_io_entry[171:140],
	       ", ",
	       "data: ",
	       "'h%h",
	       ma_allocate_io_entry[139:76],
	       ", ",
	       "size: ",
	       "'h%h",
	       ma_allocate_io_entry[75:73],
	       ", ",
	       "epoch: ",
	       "'h%h",
	       ma_allocate_io_entry[72],
	       ", ",
	       "access: ",
	       "'h%h",
	       ma_allocate_io_entry[71:70],
	       ", ",
	       "atomic_op: ",
	       "'h%h",
	       ma_allocate_io_entry[69:65],
	       ", ",
	       "vaddr: ",
	       "'h%h",
	       ma_allocate_io_entry[64:1],
	       ", ",
	       "is_ptw_req: ",
	       "True",
	       " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io &&
	  TASK_testplusargs_7_OR_TASK_testplusargs_8_AND_ETC___d91)
	$write("DCACHE: Allocating IO Buff tail:%d",
	       rg_tail,
	       "IoEntry { ",
	       "address: ",
	       "'h%h",
	       ma_allocate_io_entry[171:140],
	       ", ",
	       "data: ",
	       "'h%h",
	       ma_allocate_io_entry[139:76],
	       ", ",
	       "size: ",
	       "'h%h",
	       ma_allocate_io_entry[75:73],
	       ", ",
	       "epoch: ",
	       "'h%h",
	       ma_allocate_io_entry[72],
	       ", ",
	       "access: ",
	       "'h%h",
	       ma_allocate_io_entry[71:70],
	       ", ",
	       "atomic_op: ",
	       "'h%h",
	       ma_allocate_io_entry[69:65],
	       ", ",
	       "vaddr: ",
	       "'h%h",
	       ma_allocate_io_entry[64:1],
	       ", ",
	       "is_ptw_req: ",
	       "False",
	       " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_allocate_io &&
	  (TASK_testplusargs___d77 ||
	   TASK_testplusargs___d78 && TASK_testplusargs___d79))
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkiobuffer

